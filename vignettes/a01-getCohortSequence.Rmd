---
title: "Create a new table with the index and marker cohorts"
author: Xihang Chen, Tyman Stanford, Berta Raventós, Nicole Pratt, Ed Burn, Martí Català, Danielle Newby, Núria Mercadé-Besora, Mike Du, Yuchen Guo, Kim Lopez, Marta Alcalde-Herraiz
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Create a new table with the index and marker cohorts}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

In this vignette we will introduce the functionalities of `getCohortSequence()` function. The goal of this function is to intersect the index and the marker cohorts before being used to calculate the Sequence Symmetry Ratios.

First of all, we will use `mockDrugUtilisation()` from DrugUtilisation package to create a mock database. This cdm reference already contains two mock cohorts that we will use for the following examples.

```{r setup, message = FALSE, warning = FALSE}
library(CohortSymmetry)
library(DrugUtilisation)
library(dplyr)
library(CDMConnector)
library(DBI)
library(duckdb)

cdm <- mockDrugUtilisation(
  numberIndividuals = 100)
attr(cdm,"write_schema") <- "main"
cdm
```

We rename both cohorts as `index = cohort1` and `marker = cohort2`. Notice that the cohorts can correspond to either a drug exposure or a condition. 

```{r message = FALSE, warning = FALSE}
cdm[["index"]] <- cdm[["cohort1"]]  |> 
  compute(name = "index", temporary = FALSE)

cdm[["marker"]] <- cdm[["cohort2"]] |> 
  compute(name = "marker", temporary = FALSE)

dropTable(cdm, c("cohort1","cohort2"))
```

# Merge the index and the marker cohorts

Let us see an example on how we can merge the index and the marker cohorts using the `getCohortSequence()` function:

```{r message = FALSE, warning = FALSE}
cdm <- cdm |>
  getCohortSequence(
    indexTable  = "index",
    markerTable = "marker"
  )

cdm
```

By default, this function will create a new table in the cdm object named **joined_cohorts**. You can costume the name by using the `name` parameter.

```{r message = FALSE, warning = FALSE}
cdm[["joined_cohorts"]]
```

The columns of this table correspond to:

-   **index_id**: cohort_definition_id of the index cohort.
-   **marker_id**: cohort_definition_id of the marker cohort.
-   **subject_id**: individual identification.
-   **ìndex_date**: cohort_start_date of the index cohort.
-   **marker_date**: cohort_start_date of the marker cohort.
-   **first_date**: earliest date between `ìndex_date` and `marker_date`.
-   **second_date**: latest date between `ìndex_date` and `marker_date`.

Notice that, by default, `getCohortSequence()` will include all the cohorts contained in the index and the marker tables. If we want to specify which cohorts are of interest, we can use the `indexId` and the `markerId` parameters.

```{r message = FALSE, warning = FALSE}
cdm <- cdm |>
  getCohortSequence(
    indexTable  = "index",
    markerTable = "marker",
    indexId  = 1,
    markerId = 3
  )

cdm$joined_cohorts
```

## Use dateRange to define the study period

By default, `getCohortSequence()` will not restrict the observation study period. However, we can define a range by using the `dateRange` parameter.

This parameter has to be a vector of two dates, where the first one is bigger than the second one. If no study period wants to be specified, you can just use the default option: `dateRange  = as.Date(c(NA, NA))`.

```{r message = FALSE, warning = FALSE}
cdm <- cdm |>
  getCohortSequence(
    indexTable  = "index",
    markerTable = "marker",
    dateRange   = as.Date(c("2000-01-01","2005-01-01"))
  )

cdm$joined_cohorts
```

## Use daysPriorObservation to define the minimum prior observation 
Restrict the analysis to people with a minimum observation period before the cohort start date by using the `daysPriorObservation` parameter. Default is 0.
```{r}
cdm <- cdm |>
  getCohortSequence(
    indexTable  = "index",
    markerTable = "marker",
    name = "joined_cohorts",
    daysPriorObservation = 365
  )

cdm$joined_cohorts
```

## Use washoutWindow to remove people with previous history of the treatments

Costume the `washoutWindow` parameter to specify a washout period for both, the index cohort and the marker cohort. Notice that the parameter will correspond to the number of days for the washout.

```{r}
cdm <- cdm |>
  getCohortSequence(
    indexTable  = "index",
    markerTable = "marker",
    name = "joined_cohorts",
    washoutWindow = 365
  )

cdm$joined_cohorts
```

## Use indexMarkerGap and combinationWindow to impose time restrictions

Use `indexMarkerGap` to define the maximum number of days between the start of the second episode (either if is the index or the marker) and the end of the first episode. That means:

<p style="text-align:center;">indexMarkerGap = second_episode(cohort_start_date) - first_episode(cohort_end_date)</p>

See example bellow, where we have restricted the analysis to participants where the gap between the start date of the second episode and the end date of the first episode is equal or smaller than 10.
```{r}
cdm <- cdm |>
  getCohortSequence(
    indexTable  = "index",
    markerTable = "marker",
    name = "joined_cohorts",
    indexMarkerGap = 10
  )

cdm$joined_cohorts
```

Use `combinationWindow` to define the maximum day difference between the two starts of both events. It is defined as a numerical vector with two parameters; the first parameter must be bigger than the second one. That means:

<p style="text-align:center;"> x = second_episode(cohort_start_date) - first_episode(cohort_start_date) </p>

<p style="text-align:center;"> combinationWindow[1] $<$ x $\leq$ combinationWindow[2] </p>

In other words, if we define `combinationWindow = c(0,365)`, it means that the gap between the start date of the second episode and the first episode should be larger than 0 and less or equal than 365.

```{r}
cdm <- cdm |>
  getCohortSequence(
    indexTable  = "index",
    markerTable = "marker",
    name = "joined_cohorts",
    combinationWindow = c(0,180)
  )

cdm$joined_cohorts
```
